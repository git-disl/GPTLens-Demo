[
    {
        "function_name": "withdraw",
        "vulnerability": "Re-entrancy attack",
        "criticism": "The reasoning is correct. The 'transfer' function call is not protected against re-entrancy. An attacker can re-enter the function to drain the contract's Ether. The state variables should be updated before the transfer call. The severity is high because it can lead to loss of funds. The profitability is also high because an attacker can drain all the Ether from the contract.",
        "correctness": 9,
        "severity": 9,
        "profitability": 9,
        "reason": "The 'transfer' function call is not protected against re-entrancy. An attacker can re-enter the function to drain the contract's Ether. The state variables should be updated before the transfer call.",
        "code": "function withdraw() public { require(worldOwner == msg.sender); lottoIndex += 1; numtickets = 0; totalBounty = 0; worldOwner.transfer(this.balance); }",
        "label": "Bad Randomness",
        "file_name": "2018-15552.sol",
        "description": "The \"PayWinner\" function of a simplelottery smart contract implementation for The Ethereum Lottery, an Ethereum gambling game, generates a random value with publicly readable variable \"maxTickets\" (which is private, yet predictable and readable by the eth.getStorageAt function). Therefore, it allows attackers to always win and get rewards."
    },
    {
        "function_name": "AddTicket",
        "vulnerability": "Denial of service",
        "criticism": "The reasoning is correct. The function does not handle failure of the 'payWinner' function call. If the 'payWinner' function call fails, the contract will be stuck in a state where no further tickets can be added. The severity is high because it can halt the contract's functionality. The profitability is low because an attacker cannot directly profit from this vulnerability.",
        "correctness": 9,
        "severity": 8,
        "profitability": 1,
        "reason": "The function does not handle failure of the 'payWinner' function call. If the 'payWinner' function call fails, the contract will be stuck in a state where no further tickets can be added.",
        "code": "function AddTicket() public payable { require(msg.value == ticketPrice); require(numtickets < maxTickets); lastTicketTime = now; numtickets += 1; totalBounty += ticketPrice; bool success = numtickets == maxTickets; NewTicket(msg.sender, success); if(success) { PayWinner(msg.sender); } }",
        "label": "Bad Randomness",
        "file_name": "2018-15552.sol",
        "description": "The \"PayWinner\" function of a simplelottery smart contract implementation for The Ethereum Lottery, an Ethereum gambling game, generates a random value with publicly readable variable \"maxTickets\" (which is private, yet predictable and readable by the eth.getStorageAt function). Therefore, it allows attackers to always win and get rewards."
    },
    {
        "function_name": "PayWinner",
        "vulnerability": "Integer underflow",
        "criticism": "The reasoning is correct. This function does not check if 'maxTickets' is greater than 0 before subtracting 1. This can lead to integer underflow, where 'maxTickets' becomes a very large number. The severity is high because it can lead to unexpected behavior of the contract. The profitability is moderate because an attacker can manipulate the number of tickets, but it does not directly lead to financial gain.",
        "correctness": 9,
        "severity": 8,
        "profitability": 5,
        "reason": "This function does not check if 'maxTickets' is greater than 0 before subtracting 1. This can lead to integer underflow, where 'maxTickets' becomes a very large number.",
        "code": "function PayWinner( address winner ) private { require(numtickets == maxTickets); uint ownerTax = 6 * totalBounty / 100; uint winnerPrice = totalBounty - ownerTax; LottoComplete(msg.sender, lottoIndex, winnerPrice); lottoIndex += 1; numtickets = 0; totalBounty = 0; if(_direction == 0 && maxTickets < 20) maxTickets += 1; if(_direction == 1 && maxTickets > 10) maxTickets -= 1; if(_direction == 0 && maxTickets == 20) _direction = 1; if(_direction == 1 && maxTickets == 10) _direction = 0; worldOwner.transfer(ownerTax); winner.transfer(winnerPrice); }",
        "label": "Bad Randomness",
        "file_name": "2018-15552.sol",
        "description": "The \"PayWinner\" function of a simplelottery smart contract implementation for The Ethereum Lottery, an Ethereum gambling game, generates a random value with publicly readable variable \"maxTickets\" (which is private, yet predictable and readable by the eth.getStorageAt function). Therefore, it allows attackers to always win and get rewards."
    }
]