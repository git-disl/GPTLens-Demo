[
    {
        "function_name": "transferFrom",
        "vulnerability": "Incorrect condition for allowance",
        "criticism": "The reasoning is correct. The condition should check if 'allowed[from][msg.sender]' is less than 'value' and not the other way around. This can allow unauthorized transfers. The severity is high because it can lead to unauthorized transfers. The profitability is also high because an attacker can transfer more tokens than allowed.",
        "correctness": 9,
        "severity": 9,
        "profitability": 9,
        "reason": "The condition should check if 'allowed[from][msg.sender]' is less than 'value' and not the other way around. This can allow unauthorized transfers.",
        "code": "function transferFrom(address from, address to, uint value) returns (bool success) {\n    if (frozenAccount[msg.sender]) return false;\n    if(balances[from] < value) return false;\n    if( allowed[from][msg.sender] >= value ) return false;\n    if(balances[to] + value < balances[to]) return false;\n    balances[from] -= value;\n    allowed[from][msg.sender] -= value;\n    balances[to] += value;\n    Transfer(from, to, value);\n    return true;\n}",
        "label": "Wrong Logic",
        "file_name": "2018-12025.sol",
        "description": "The transferFrom function of a smart contract implementation for FuturXE (FXE), an Ethereum ERC20 token, allows attackers to accomplish an unauthorized transfer of digital assets because of a logic error. The developer messed up with the boolean judgment - if the input value is smaller than or equal to allowed value, the transfer session would stop execution by returning false. This makes no sense, because the transferFrom() function should require the transferring value to not exceed the allowed value in the first place. Suppose this function asks for the allowed value to be smaller than the input. Then, the attacker could easily ignore the allowance: after this condition, the `allowed[from][msg.sender] -= value;` would cause an underflow because the allowed part is smaller than the value. The attacker could transfer any amount of FuturXe tokens of any accounts to an appointed account (the `_to` address) because the allowed value is initialized to 0, and the attacker could bypass this restriction even without the victim's private key.",
        "final_score": 9.0
    },
    {
        "function_name": "freezeAccount",
        "vulnerability": "Arbitrary Account Freezing",
        "criticism": "The reasoning is correct. The contract owner can arbitrarily freeze any account. This can lead to funds being locked without the account owner's consent. The severity is high because it can lead to loss of funds. The profitability is low because an external attacker cannot profit from it.",
        "correctness": 9,
        "severity": 9,
        "profitability": 0,
        "reason": "The contract owner can arbitrarily freeze any account. This can lead to funds being locked without the account owner's consent.",
        "code": "function freezeAccount(address target, bool freeze) onlyOwner { frozenAccount[target] = freeze; FrozenFunds(target, freeze); }",
        "label": "Wrong Logic",
        "file_name": "2018-12025.sol",
        "description": "The transferFrom function of a smart contract implementation for FuturXE (FXE), an Ethereum ERC20 token, allows attackers to accomplish an unauthorized transfer of digital assets because of a logic error. The developer messed up with the boolean judgment - if the input value is smaller than or equal to allowed value, the transfer session would stop execution by returning false. This makes no sense, because the transferFrom() function should require the transferring value to not exceed the allowed value in the first place. Suppose this function asks for the allowed value to be smaller than the input. Then, the attacker could easily ignore the allowance: after this condition, the `allowed[from][msg.sender] -= value;` would cause an underflow because the allowed part is smaller than the value. The attacker could transfer any amount of FuturXe tokens of any accounts to an appointed account (the `_to` address) because the allowed value is initialized to 0, and the attacker could bypass this restriction even without the victim's private key.",
        "final_score": 6.75
    },
    {
        "function_name": "mintToken",
        "vulnerability": "Arbitrary Minting",
        "criticism": "The reasoning is correct. The owner of the contract can mint arbitrary tokens. This could lead to an arbitrary increase in the token supply, devaluing existing tokens. However, isn't inherently a vulnerability, but rather a design decision that might be questionable. The severity is moderate because it is based on the owner's intention. The profitability is low because an external attacker cannot profit from it.",
        "correctness": 7,
        "severity": 4,
        "profitability": 0,
        "reason": "Only the contract owner has the authority to mint tokens. This can lead to an arbitrary increase in the token supply, devaluing existing tokens.",
        "code": "function mintToken(address target, uint256 mintedAmount) onlyOwner{ balances[target] += mintedAmount; totalSupply += mintedAmount; Transfer(0,owner,mintedAmount); Transfer(owner,target,mintedAmount); }",
        "label": "Wrong Logic",
        "file_name": "2018-12025.sol",
        "description": "The transferFrom function of a smart contract implementation for FuturXE (FXE), an Ethereum ERC20 token, allows attackers to accomplish an unauthorized transfer of digital assets because of a logic error. The developer messed up with the boolean judgment - if the input value is smaller than or equal to allowed value, the transfer session would stop execution by returning false. This makes no sense, because the transferFrom() function should require the transferring value to not exceed the allowed value in the first place. Suppose this function asks for the allowed value to be smaller than the input. Then, the attacker could easily ignore the allowance: after this condition, the `allowed[from][msg.sender] -= value;` would cause an underflow because the allowed part is smaller than the value. The attacker could transfer any amount of FuturXe tokens of any accounts to an appointed account (the `_to` address) because the allowed value is initialized to 0, and the attacker could bypass this restriction even without the victim's private key.",
        "final_score": 4.5
    }
]