import tkinter as tk
from tkinter import ttk
import os
from PIL import Image, ImageTk
import json
from tkinter import CENTER
import fitz  # PyMuPDF
from prompts import *
import os

class GPTLensGUI:
    def __init__(self, root):
        self.root = root
        self.root.title("GPTLens Data Pipelining GUI")
        self.root.geometry("1300x900")
        self.color='steel blue'
        self.data_dir = 'data_sample/CVE_clean'
        # self.preprocessed_dir = 'data_sample/CVE_clean'
        self.auditor_dirs = [
            'results/auditor_gpt-4_0.7_top3_1',
        ]
        self.critic_dirs = [
            'results/auditor_gpt-4_0.7_top3_1/critic_gpt-4_0_1_zero_0928',
            # 'results/auditor_gpt-4_0.7_top3_1/critic_gpt-4_0_1_few_1026'
        ]
        self.ranker_dirs = [
            # 'results/auditor_gpt-4_0.7_top3_1/critic_gpt-4_0_1_few_1026/ranker_default',
            'results/auditor_gpt-4_0.7_top3_1/critic_gpt-4_0_1_zero_0928/ranker_default'
        ]
        self.label_path = 'data_full/CVE_label/CVE2label.json'
        self.description_path = 'data_full/CVE_label/CVE2description.json'
        self.filter_on_data = ''

        # Create an instance of Style widget
        style=ttk.Style()
        style.theme_use('clam')
        self.font_size=12

        self.create_images()
        # self.setup_ui()
        self.make_cover_screen()  # Create the cover screen before setting up the main UI
    def create_images(self):
        # Load the arrow image
        original_image = Image.open("src/assets/arrow.png")
        resized_image = original_image.resize((50, 50), Image.Resampling.LANCZOS)
        self.arrow_image = ImageTk.PhotoImage(resized_image)


        settings_icon_path = "src/assets/gear.png"  # Replace with your settings icon path
        settings_icon_image = Image.open(settings_icon_path)
        self.settings_icon = ImageTk.PhotoImage(settings_icon_image.resize((25, 25), Image.Resampling.LANCZOS))

        auditor_icon_path = "src/assets/auditor.png"  # Replace with your settings icon path
        auditor_icon_image = Image.open(auditor_icon_path)
        self.auditor_icon = ImageTk.PhotoImage(auditor_icon_image.resize((100,100), Image.Resampling.LANCZOS))

        critic_icon_path = "src/assets/critic.png"  # Replace with your settings icon path
        critic_icon_image = Image.open(critic_icon_path)
        self.critic_icon = ImageTk.PhotoImage(critic_icon_image.resize((100,100), Image.Resampling.LANCZOS)) 


        cover_path = "src/assets/cover.png"  # Replace with your settings icon path
        cover_image = Image.open(cover_path)
        self.cover_image = ImageTk.PhotoImage(cover_image.resize((400,400), Image.Resampling.LANCZOS)) 
        

    def make_cover_screen(self):
        # This window acts as a cover screen
        self.cover_screen = tk.Toplevel(self.root)
        self.cover_screen.title("Welcome to GPTLens")
        self.cover_screen.geometry("1300x900")
        self.cover_screen.protocol("WM_DELETE_WINDOW", self.close_application)  # Handle the close button

        # Create a Canvas widget
        canvas = tk.Canvas(self.cover_screen, width=1300, height=900)
        canvas.pack()

        # Place the background imageon the Canvas
        canvas.create_image(1300/2,190, image=self.cover_image)

        label = tk.Label(self.cover_screen, text="GPTLens Demo UI", font=('Arial', 40, 'bold'))
        label.place(relx=0.5, rely=0.6, anchor="center")  # Position the label relative to the window size
        attribution_text = "Generated by DALLÂ·E-3 | Image by Sihao Hu"
        attribution_label = tk.Label(self.cover_screen, text=attribution_text, font=('Arial', 12))
        attribution_label.place(relx=0.5, rely=0.515, anchor="center")  # Position the label relative to the window size

        label = tk.Label(self.cover_screen, text="""GPT Lens is an LLM tool to check for security breaches in smart contracts.
                          To learn more, go to : https://github.com/git-disl/GPTLens. This demo provides a scenario-based walkthrough of how 
                         GPTLens utilizes LLMs to examine smart contract code and detect vulnerabilities.
                          """)
        label.place(relx=0.5, rely=0.7, anchor="center")  # Position the label relative to the window size

        start_button = tk.Button(self.cover_screen, text="Start Demo", font=('Arial', 20), command=self.show_pdf_slides)
        start_button.place(relx=0.5, rely=0.8, anchor="center")  # Position the button relative to the window size
        
        self.root.withdraw()
    def show_pdf_slides(self):
        self.cover_screen.destroy()
        self.root.deiconify() 
        
        self.setup_scroll_and_window()

        pdf_path = "src/assets/GPT-Lens-demo-slide.pdf"
        pg=[]
        for i in range(0,6):
            pg.append(self.load_page(pdf_path,i))

        self.title_bar_container = tk.Frame(self.main_frame, bg=self.color, highlightbackground="black", highlightthickness=0.5)
        self.title_bar_container.grid(row=0, column=0, sticky='ew')  # Span across all columns horizontally
        self.title_bar_container.grid_columnconfigure(0, minsize=1300) # Allow expansion of the column

        label = tk.Label(self.title_bar_container, text="GPT-lens Architecture Overview", font=('Arial', 30, 'bold'), bg=self.color)
        label.grid(row=0, column=0, sticky='new', pady=15, padx=10)  # Span only the first column

        label = tk.Label(self.title_bar_container, 
                        text="Scroll down to view a demonstration on GPT-Lens architecture, click 'Next' to go to data walkthrough", 
                        font=('Arial', 14),
                        bg=self.color)
        label.grid(row=1, column=0, sticky='n', pady=0, padx=10)  # Span only the first column

        self.slide_frame = tk.Frame(self.main_frame)
        self.slide_frame.grid(row=1,column=0, sticky='n')  # Adjusted packing to span whole width
        self.main_frame.grid_columnconfigure(0, weight=1)
        self.slide_frame.grid_columnconfigure(0, weight=1)

        # Create a label to display the image
        for i,p in enumerate(pg):
            pdf_label = tk.Label(self.slide_frame, image=p)
            pdf_label.image = p  # Keep a reference to prevent garbage collection
            pdf_label.grid(row=i, column=1, sticky='n', pady=0, padx=10) 

        # Button to go to data walkthrough
        data_button = tk.Button(self.main_frame, text="Next", command=self.setup_ui)
        data_button.grid()


        
    def load_page(self, path, page_n):
        doc = fitz.open(path)
        page = doc.load_page(page_n)
        pix = page.get_pixmap(matrix=fitz.Matrix(1.333, 1.333))  # Adjust for display
        img = Image.frombytes("RGB", [pix.width, pix.height], pix.samples)
        img = ImageTk.PhotoImage(img)
        return img

    def close_application(self):
        # Close the entire application
        self.root.quit()
        self.root.destroy()

    def setup_ui(self):
        # Code related to UI setup, scrollbar, frames, etc.
        # self.pdf_window.destroy()
        self.canvas.delete("all")
        for widget in self.root.winfo_children():
            widget.destroy()
        self.root.deiconify() 
        self.setup_scroll_and_window()
        self.setup_frames()
    
    def update_font_size(self, event=None):
        new_size = self.font_scale.get()
        self.font_size=new_size
        new_font = ('TkDefaultFont', new_size)
        widgets = [
            self.preprocess_text,
            self.data_description,
            self.auditor_text1,
            self.auditor_text2,
            self.critic_text,
            self.auditor_prompt_text,
            self.critic_prompt_text
        ]
        for text in widgets:
             text.configure(font=new_font)
             
        # Update treeview font size as well
        style = ttk.Style(self.root)
        style.configure('Treeview', font=new_font)

    def setup_scroll_and_window(self):
        # vertical scrollbar
        scroll_y = tk.Scrollbar(self.root)
        scroll_y.pack(side='right', fill='y')

        # Horizontal scrollbar
        scroll_x = tk.Scrollbar(self.root, orient='horizontal')
        scroll_x.pack(side='bottom', fill='x')

        self.canvas = tk.Canvas(self.root, yscrollcommand=scroll_y.set, xscrollcommand=scroll_x.set)
        self.canvas.pack(side='left', fill='both', expand=True)

        scroll_y.config(command=self.canvas.yview)
        scroll_x.config(command=self.canvas.xview)

        self.canvas.bind_all("<MouseWheel>", self.on_mousewheel)

        self.main_frame = tk.Frame(self.canvas)
        self.canvas.create_window((0, 0), window=self.main_frame, anchor="nw")  # Anchor to the northwest corner
        self.main_frame.bind('<Configure>', lambda e: self.canvas.configure(scrollregion=self.canvas.bbox("all")))

    def setup_frames(self):

        # Add method calls to create different frames and load UI components
        self.create_containers(color=self.color)
        self.create_title(color=self.color)
        self.create_dropdown()
        self.create_preprocessing_frame()
        self.create_auditor_frame()
        self.create_critic_frame()
        self.create_ranker_frame()
        self.create_ack()
    def create_ack(self):
        # Title label for the first textbox
        label1 = tk.Label(self.acknowldgement, text="""Acknowledgement: This is a mini-project Yining Yuan did with GIT DiSL group under the supervision of Prof. Dr. Ling Liu 
                          and PhD student Sihao Hu. For more detailed information on GPTLens, see the paper (https://arxiv.org/pdf/2310.01152.pdf) and open source code 
                          (https://github.com/git-disl/GPTLens?tab=readme-ov-file) and for technical questions, consult with Sihao Hu.""",fg="gray")
        label1.grid(row=0, column=0, sticky='n',padx=10)



    def create_containers(self,color=None):

        self.title_bar_container = tk.Frame(self.main_frame,bg=color,highlightbackground="black", highlightthickness=0.5)
        self.title_bar_container.grid_columnconfigure(0, weight=1)  # This will allow the column to expand
        self.title_bar_container.grid_columnconfigure(0, minsize=1300)

        self.dropdown_frame = tk.Frame(self.main_frame)
        self.preprocessing_frame = tk.Frame(self.main_frame)
        self.auditor_prompt_text_frame=tk.Frame(self.main_frame)
        self.auditor_container = tk.Frame(self.main_frame)
        self.auditor_textboxes_frame = tk.Frame(self.main_frame)

        self.critic_prompt_text_frame=tk.Frame(self.main_frame)
        self.critic_container = tk.Frame(self.main_frame)
        self.critic_textboxes_frame = tk.Frame(self.main_frame)
        self.ranker_container = tk.Frame(self.main_frame)
        self.acknowldgement = tk.Frame(self.main_frame)
        
        self.title_bar_container.pack(fill='x', expand=True, padx=0)

        self.dropdown_frame.pack(fill='x')

        self.preprocessing_frame.pack(fill='x')   # Pack the container frames vertically
        self.create_section_frame(self.main_frame, "Auditor Input: Prompts", self.arrow_image)
        self.auditor_prompt_text_frame.pack(fill='x')
        self.auditor_container.pack(fill='x', pady=10)
        self.auditor_textboxes_frame.pack(fill='x', pady=10)
        self.create_section_frame(self.main_frame, "Critic Input: Prompts", self.arrow_image)
        self.critic_prompt_text_frame.pack(fill='x')
        self.critic_container.pack(fill='x',pady=10)
        self.critic_textboxes_frame.pack(fill='x', pady=10)
        self.ranker_container.pack(fill='x', pady=10)
        self.acknowldgement.pack(fill='x', pady=10)

    def create_title(self,color=None):
        label = tk.Label(self.title_bar_container, text="GPT-Lens Demo", font=('Arial', 30, 'bold'),bg=color)
        label.grid(row=0, column=0, sticky='n',pady=15,padx=10)  # Span only the first column

        label = tk.Label(self.title_bar_container, 
                         text="""Click on the dropdown bar to select data, click 'load data' to display data.""", 
                         font=('Arial',14),
                         bg=color)
        label.grid(row=1, column=0, sticky='n',pady=0,padx=10)  # Span only the first column




        self.settings_button = tk.Button(self.title_bar_container, image=self.settings_icon, command=self.on_settings_icon_click, borderwidth=0)
        self.settings_button.image = self.settings_icon  # Keep a reference to the image
        self.settings_button.grid(row=0, column=0, sticky='nw',pady=5,padx=20) 
        
    def on_settings_icon_click(self):
        # Method bound to the settings icon click event
        self.create_font_size_adjuster()
    def create_font_size_adjuster(self):
        # Create a new Toplevel window
        self.font_size_window = tk.Toplevel(self.root)
        self.font_size_window.title("Adjust Font Size")
        self.font_size_window.geometry("250x100")  # Width x Height
        
        self.font_scale = tk.Scale(self.font_size_window, from_=8, to=19, orient='horizontal', label='Font Size',
                                   command=self.update_font_size)
        self.font_scale.set(self.font_size)  # Default font size
        self.font_scale.grid(row=0,column=0,sticky='e', padx=10, pady=5)
        
    def create_dropdown(self):
        # Dropdown for file selection
        self.file_var = tk.StringVar()
        self.dropdown = ttk.Combobox(self.dropdown_frame, textvariable=self.file_var, state='readonly')
        self.dropdown.grid(row=0, column=0, sticky='ew', padx=10, pady=10)
        
        # Use lambda to delay execution of self.load_data until the button is actually clicked
        self.load_button = tk.Button(self.dropdown_frame, text="Load Data", command=lambda: self.load_data(self.dropdown.get()))
        self.load_button.grid(row=0, column=1, sticky='w', padx=10, pady=10)

        # Ensure that the dropdown is cleared each time before updating
        self.dropdown['values'] = []  # Reset the dropdown values
        try:
            # List all files in the data directory that match a file condition (if needed)
            files = sorted([f for f in os.listdir(self.data_dir) if os.path.isfile(os.path.join(self.data_dir, f))])
            # Set the first file in the list as the current value (if list is not empty)
            if files:
                self.dropdown['values'] = files  # Update the dropdown list with file names
                self.file_var.set(files[0])  # Set the first item as the current selected value
        except Exception as e:
            print(f"Failed to update dropdown: {e}")


    def create_preprocessing_frame(self):
        # Configure the grid to provide appropriate space for the text widget and scrollbar
        self.preprocessing_frame.grid_rowconfigure(1, weight=1)
        self.preprocessing_frame.grid_columnconfigure(0, weight=0)  # Set weight to 0 so it doesn't expand

        label = tk.Label(self.preprocessing_frame, text="Preprocessed Data", font=('Helvetica', 15, 'bold'))
        label.grid(row=0, column=0, sticky='nw')  # Span only the first column

        # Title label for the second textbox
        description_label0 = tk.Label(self.preprocessing_frame, text='Code')
        description_label0.grid(row=1, column=0, sticky='nw', padx=10)

        # Text widget for preprocessed data
        self.preprocess_text = tk.Text(self.preprocessing_frame, height=15, width=100)
        self.preprocess_text.grid(row=2, column=0, sticky='nw', padx=10,pady=5)

        # Scrollbar for the text widget
        scrollbar = tk.Scrollbar(self.preprocessing_frame, command=self.preprocess_text.yview)
        scrollbar.grid(row=2, column=0, sticky='nse',pady=5)  # Sticks to north and south, separate column for scrollbar
        self.preprocess_text.config(yscrollcommand=scrollbar.set)



        # Title label for the second textbox
        description_label = tk.Label(self.preprocessing_frame, text='Code Description')
        description_label.grid(row=3, column=0, sticky='nw', padx=10, pady=5)

        # Text widget for code description
        self.data_description = tk.Text(self.preprocessing_frame, height=10, width=100)
        self.data_description.grid(row=4, column=0, sticky='nw', padx=10, pady=5)

        # Scrollbar for the text widget
        scrollbar = tk.Scrollbar(self.preprocessing_frame, command=self.data_description.yview)
        scrollbar.grid(row=4, column=0, sticky='nse',pady=5)
        self.data_description.config(yscrollcommand=scrollbar.set)


    def create_auditor_frame(self):

        def on_tree_select_auditor(event):
            item = self.auditor_view.focus()  # Get the focused item (selected row)
            if item:
                item_data = self.auditor_view.item(item, 'values')  # Get the data associated with the selected row
                if item_data:
                    file_name = item_data[0]  # Assuming 'file_name' is at index 0
                    function_name=item_data[1]
                    vuln=item_data[2]
                    # Construct the path to the JSON file based on the selected row's data
                    for auditor_dir in self.auditor_dirs:
                            
                        # Deal with filename that needs to add CVE
                        json_path = os.path.join(auditor_dir, 'CVE-'+file_name.replace('.sol', '.json'))

                        if os.path.exists(json_path):
                            # Load JSON data
                            with open(json_path, 'r') as file:
                                data = json.load(file)
                                # Find the corresponding entry in the JSON data
                                for entry in data:
                                    if (entry.get('function_name') == function_name) and (entry.get('vulnerability') == vuln):
                                        # Extract the 'reason' and 'code' values
                                        reason = entry.get('reason', '')
                                        code = entry.get('code', '')
                                        # Clear existing text in the textboxes
                                        self.auditor_text1.delete('1.0', tk.END)
                                        self.auditor_text2.delete('1.0', tk.END)
                                        # Insert the 'reason' and 'code' values into the textboxes
                                        self.auditor_text1.insert(tk.END, reason)
                                        self.auditor_text2.insert(tk.END, code)
        # ___________________________auditor input_______________________________
        # First textbox
        self.auditor_prompt_text = tk.Text(self.auditor_prompt_text_frame, height=10, width=100)
        self.auditor_prompt_text.grid(row=0, column=0, sticky='nw',padx=10)
        
        # Scrollbar for the text widget
        scrollbar = tk.Scrollbar(self.auditor_prompt_text_frame, command=self.auditor_prompt_text.yview)
        scrollbar.grid(row=0, column=0, sticky='nse',pady=5) 
        self.auditor_prompt_text.config(yscrollcommand=scrollbar.set)

        arrow_label = tk.Label(self.auditor_prompt_text_frame, image=self.arrow_image)
        arrow_label.grid(row=1, column=0, sticky='nw') 

        label = tk.Label(self.auditor_prompt_text_frame, text="Auditor Generating Answer...", font=('Helvetica', 15, 'bold'))
        label.grid(row=2, column=0, sticky='nw') 

        auditor_icon = tk.Label(self.auditor_prompt_text_frame, image=self.auditor_icon)
        auditor_icon.grid(row=3, column=0, sticky='nw',padx=10,pady=10) 

        # ___________________________auditor output_______________________________

        self.auditor_frame = self.create_section_frame(self.auditor_container, "Auditor Output", self.arrow_image)
        self.auditor_view = ttk.Treeview(self.auditor_frame,column=("c1", "c2","c3"), show="headings",height=8)
        # Bind the function to the Treeview's <<TreeviewSelect>> event
        self.auditor_view.bind('<<TreeviewSelect>>', on_tree_select_auditor)
        self.auditor_view.pack(fill='both', padx=10, pady=10)
        self.auditor_frame.pack(fill='x', padx=5, pady=5, side='left')

        # Title label for the first textbox
        label1 = tk.Label(self.auditor_textboxes_frame, text='Reason')
        label1.grid(row=1, column=0, sticky='w',padx=10)

        # Title label for the second textbox
        label2 = tk.Label(self.auditor_textboxes_frame, text='Code')
        label2.grid(row=1, column=2, sticky='w',padx=10)

        # First textbox
        self.auditor_text1 = tk.Text(self.auditor_textboxes_frame, height=10, width=60)
        self.auditor_text1.grid(row=2, column=0, sticky='nw',padx=10,pady=5)


        # Scrollbar for the text widget
        scrollbar = tk.Scrollbar(self.auditor_textboxes_frame, command=self.auditor_text1.yview)
        scrollbar.grid(row=2, column=0, sticky='nse',pady=5)  
        self.auditor_text1.config(yscrollcommand=scrollbar.set)

        # Second textbox
        self.auditor_text2 = tk.Text(self.auditor_textboxes_frame, height=10, width=60)
        self.auditor_text2.grid(row=2, column=2, sticky='nw',padx=10,pady=5)

        # Scrollbar for the text widget
        scrollbar = tk.Scrollbar(self.auditor_textboxes_frame, command=self.auditor_text2.yview)
        scrollbar.grid(row=2, column=2, sticky='nse',pady=5)  
        self.auditor_text2.config(yscrollcommand=scrollbar.set)
        # Title label for the first textbox
        label_instruction = tk.Label(self.auditor_frame, text='Click on entry in auditor output to show reason and code')
        label_instruction.pack()

    def create_critic_frame(self):

        def on_tree_select_critic(event):
            item = self.critic_view.focus()  # Get the focused item (selected row)
            if item:
                item_data = self.critic_view.item(item, 'values')  # Get the data associated with the selected row
                if item_data:
                    function_name = item_data[0]
                    vulnerability = item_data[1]
                    file_name = item_data[5]  # Assuming 'file_name' is at index 5
                    # Construct the path to the JSON file based on the selected row's data
                    for critic_dir in self.critic_dirs:
                        json_path = os.path.join(critic_dir, 'CVE-'+file_name.replace('.sol', '.json'))
                        if os.path.exists(json_path):
                            # Load JSON data
                            with open(json_path, 'r') as file:
                                data = json.load(file)
                                # Find the corresponding entry in the JSON data
                                for entry in data:
                                    if entry.get('function_name') == function_name and entry.get('vulnerability') == vulnerability:
                                        # Extract the 'critic' score
                                        critic = entry.get('criticism','')
                                        # Clear existing text in the textboxes
                                        self.critic_text.delete('1.0', tk.END)
                                        # Insert the 'critic' score into the textboxes
                                        self.critic_text.insert(tk.END, critic)
        # ___________________________critic input_______________________________
        # First textbox
        self.critic_prompt_text = tk.Text(self.critic_prompt_text_frame, height=10, width=100)
        self.critic_prompt_text.grid(row=0, column=0, sticky='nw',padx=10,pady=5)
        
        # Scrollbar for the text widget
        scrollbar = tk.Scrollbar(self.critic_prompt_text_frame, command=self.critic_prompt_text.yview)
        scrollbar.grid(row=0, column=0, sticky='nse',pady=5) 
        self.critic_prompt_text.config(yscrollcommand=scrollbar.set)

        arrow_label = tk.Label(self.critic_prompt_text_frame, image=self.arrow_image)
        arrow_label.grid(row=1, column=0, sticky='nw') 

        label = tk.Label(self.critic_prompt_text_frame, text="Critic Generating Answer...", font=('Helvetica', 15, 'bold'))
        label.grid(row=2, column=0, sticky='nw') 

        critic_icon = tk.Label(self.critic_prompt_text_frame, image=self.critic_icon)
        critic_icon.grid(row=3, column=0, sticky='nw',padx=10,pady=10) 

        # ___________________________critic input_______________________________
        self.critic_frame = self.create_section_frame(self.critic_container, "Critic Output", self.arrow_image)
        self.critic_view = ttk.Treeview(self.critic_frame, column=("c1", "c2","c3","c4","c5","c6"),show="headings")
        self.critic_view.pack(fill='both', padx=10, pady=5)
        self.critic_frame.pack(fill='x', padx=10, pady=5, side='left')

        self.critic_view.bind('<<TreeviewSelect>>', on_tree_select_critic)

        # Title label for the first textbox
        label_c = tk.Label(self.critic_textboxes_frame, text='Critic')
        label_c.grid(row=1, column=0, sticky='w',padx=10)

        # critic textbox 
        self.critic_text = tk.Text(self.critic_textboxes_frame, height=15, width=100)
        self.critic_text.grid(row=2, column=0, sticky='nw',padx=10)

        # Scrollbar for the text widget
        scrollbar = tk.Scrollbar(self.critic_textboxes_frame, command=self.preprocess_text.yview)
        scrollbar.grid(row=2, column=0, sticky='nse',pady=5) 
        # Title label for the first textbox
        label_instruction = tk.Label(self.critic_frame, text='Click on entry in critic output to show criticism on auditor')
        label_instruction.pack()

    def create_ranker_frame(self):
        # Frame for ranker output
        # Ranker Output Frame
        self.ranker_frame = self.create_section_frame(self.ranker_container, "Ranker Output", self.arrow_image)
        self.ranker_view = ttk.Treeview(self.ranker_frame, column=("c1", "c2","c3","c4"), show="headings")
        self.ranker_view.pack(fill='both', padx=10, pady=5)
        self.ranker_frame.pack(fill='x', padx=10, pady=5, side='left')


    def on_mousewheel(self, event):
        self.canvas.yview_scroll(int(-1*(event.delta)), "units")
    def on_mousewheel_text(self,event):
        event.widget.yview_scroll(-1*(event.delta), "units")
    def create_section_frame(self,parent, title, arrow_image,bg=None):
        frame = tk.Frame(parent, width=100)
        frame.pack(fill='x')
        # Arrow label
        arrow_label = tk.Label(frame, image=arrow_image)
        arrow_label.pack(anchor='w')

        # Title label
        label = tk.Label(frame, text=title, font=('Helvetica', 15, 'bold'),bg=bg)
        label.pack(anchor='w') # Align to the north of the cell to stay just below the arrow
        return frame
    # Define other methods used for loading and handling data as needed

# -----load data------------------------------------------------------
    def load_data(self, file_name=None):
        # Clear previous content
        widgets = [
            self.preprocess_text,
            self.data_description,
            self.auditor_view,
            self.critic_view,
            self.ranker_view,
            self.auditor_text1,
            self.auditor_text2,
            self.critic_text,
            self.auditor_prompt_text,
            self.critic_prompt_text
        ]
        for widget in widgets:
            if isinstance(widget, tk.Text):
                widget.delete('1.0', tk.END)
            elif isinstance(widget, ttk.Treeview):
                for i in widget.get_children():
                    widget.delete(i)

        # Preprocessing result
        preprocess_path = os.path.join(self.data_dir, file_name)
        if os.path.exists(preprocess_path):
            with open(preprocess_path, 'r') as file:
                code_file=file.read()
                self.preprocess_text.insert(tk.END, code_file)
                prompt=auditor_prompt_wrap(auditor_prompt, auditor_format_constrain, code_file, 3)
                self.auditor_prompt_text.insert(tk.END,prompt)



        if os.path.exists(self.description_path):
            with open(self.description_path, 'r') as file:
                data = json.load(file)
                description_key = 'CVE-' + file_name.replace('.sol', '')
                if description_key in data:
                    self.data_description.insert(tk.END, data[description_key])
        
        for auditor_dir in self.auditor_dirs:
            # Deal with filename that needs to add CVE
            auditor_file = 'CVE-' + file_name.replace('.sol', '.json') 
            auditor_path = os.path.join(auditor_dir, auditor_file)
            self.load_auditor(auditor_path, self.auditor_view)

        for critic_dir in self.critic_dirs:
            critic_path = os.path.join(critic_dir, 'CVE-' + file_name.replace('.sol', '.json'))
            self.load_critic(critic_path, self.critic_view)

        for ranker_dir in self.ranker_dirs:
            ranker_path = os.path.join(ranker_dir,'CVE-' + file_name.replace('.sol', '.json'))
            self.load_ranker(ranker_path, self.ranker_view)
        

    def load_auditor(self,path,tree_view):
        if os.path.exists(path):
            with open(path, 'r') as file:
                data = json.load(file)
                critic_input = critic_zero_shot_prompt + "\n"+  json.dumps(data, indent=4) + "\n"+critic_format_constrain
                self.critic_prompt_text.delete('1.0', tk.END)
                self.critic_prompt_text.insert(tk.END, critic_input)

                tree_view['columns'] = ['file_name','function_name','vulnerability']
                for col in tree_view['columns']:
                    tree_view.heading(col, text=col.capitalize())
                    if col == 'Function_name':
                        tree_view.column(col, anchor=CENTER, stretch=tk.NO, width=50)
                    else:
                        tree_view.column(col, anchor=CENTER, stretch=tk.NO)
                # Insert data into treeview
                for item in data:
                    values = [item.get(key,'') for key in tree_view['columns']]
                    tree_view.insert('', 'end', values=values)
    def load_critic(self,path,tree_view):
        if os.path.exists(path):
            with open(path, 'r') as file:
                data = json.load(file)
                tree_view['columns'] = ['function_name','vulnerability','correctness','severity','profitability','file_name']
                for col in tree_view['columns']:
                    tree_view.heading(col, text=col.capitalize())
                    if col == 'Function_name':
                        tree_view.column(col, anchor=CENTER, stretch=tk.NO, width=30)
                    else:
                        tree_view.column(col, anchor=CENTER, stretch=tk.NO)
                # Insert data into treeview
                for item in data:
                    values = [item.get(key, '') for key in tree_view['columns']]
                    tree_view.insert('', 'end', values=values)

    def load_ranker(self,path,tree_view):
        if os.path.exists(path):
            with open(path, 'r') as file:
                data = json.load(file)
                tree_view['columns'] = ['function_name','vulnerability','final_score','file_name']
                for col in tree_view['columns']:
                    tree_view.heading(col, text=col.capitalize())
                    if col == 'Function_name':
                        tree_view.column(col, anchor=CENTER, stretch=tk.NO, width=30)
                    else:
                            tree_view.column(col, anchor=CENTER, stretch=tk.NO)
                # Insert data into treeview
                for item in data:
                    values = [item.get(key, '') for key in tree_view['columns']]
                    tree_view.insert('', 'end', values=values)
if __name__ == "__main__":
    root = tk.Tk()
    app = GPTLensGUI(root)
    root.mainloop()
